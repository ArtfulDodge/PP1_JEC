import java.util.Iterator;import java.util.NoSuchElementException;/** * A class that implements the ADT dictionary by using hashing and * linear probing to resolve collisions. The dictionary is unsorted, * has distinct search key, and DOES NOT SUPPORT a remove operation. Any * calls to the remove operation should throw an exception. * NOTE: Uses probe for add and getValue and linear probing. * NOTE: The Javadoc comments for the methods enforced by the  * interface Dictionary are in DictionaryInterface.java. * @author Frank M. Carrano * @author Timothy M. Henry * @author Joseph Erickson * @author Rob Kelley * @version 4.0 * Programming Project 1 * Fall 2018 */public class HashedDictionary<K, V> implements DictionaryInterface<K, V>{	// The dictionary:	private int numberOfEntries;	private static final int DEFAULT_CAPACITY = 5;     // Must be prime	private static final int MAX_CAPACITY = 10000;	// The hash table:	private TableEntry<K, V>[] hashTable;	private int tableSize;                             // Must be prime	private static final int MAX_SIZE = 2 * MAX_CAPACITY;	private boolean initialized = false;	private static final double MAX_LOAD_FACTOR = 0.5; // Fraction of hash table that can be filled	/**	 * Empty argument constructor to initialize the object.	 */	public HashedDictionary()	{	} // end default constructor	/**	 * This constructor initializes the object with a specific 	 * capacity.	 * @param initialCapacity	 */	public HashedDictionary(int initialCapacity)	{	}//end constructor		/**	 * This method will display the HashTable	 * NOTE: DO NOT CHANGE THIS METHOD	 * @return - String represention of the hash table.	 */	public String displayHashTable()	{		checkInitialization();		StringBuilder sb = new StringBuilder();		for (int index = 0; index < hashTable.length; index++)		{			if (hashTable[index] == null)				sb.append("null \n");			else				sb.append(hashTable[index].getKey() + " " + hashTable[index].getValue()+"\n");		} // end for		return sb.toString();	}//end displayHashTable	public V add(K key, V value)	{		return null;	}//end add	public V remove(K key)	{		return null;	}//end remove	public V getValue(K key)	{		return null;	}//end getValue	public boolean contains(K key)	{		return false;	}//end contains	public boolean isEmpty()	{		return false;	}//end isEmpty	public int getSize()	{		return 0;	}//end getSize	public final void clear()	{ 	}//end clear	public Iterator<K> getKeyIterator()	{ 		return null;	}//end getKeyIterator	public Iterator<V> getValueIterator()	{			return null;	}//end getValueIterator	/**	 * This method returns the hash value given a certain key	 * @param key	 * @return the hash	 */	private int getHashIndex(K key)	{		return 0;	}//end getHashIndex	/**	 * This method implements linear probing for resolving collisions.	 * Precondition: checkInitialization has been called.	 * @param index	 * @param key	 * @return	 */	private int probe(int index, K key)	{		return 0;	}//end probe		/**	 * This method increases the size of the hash table to a prime >= twice its 	 * old size. In doing so, this method must rehash the table entries.	 * Precondition: checkInitialization has been called.	 */	private void enlargeHashTable()	{	}//end enlargeHashTable	/**	 * This method checks to see if the hashtable is too ful.	 * @return true if lambda > MAX_LOAD_FACTOR for hash table	 *         return false	 */	private boolean isHashTableTooFull()	{		return false;	}//end isHashTableTooFull	/**	 * This method returns a prime integer that is >= the given integer	 * @param integer	 * @return	 */	private int getNextPrime(int integer)	{		return 0;	}//end getNextPrime	/**	 * Evaluates a given integer to determine whether or not it is prime	 * @param integer	 * @return true if the given integer is prime, false otherwise.	 */	private boolean isPrime(int integer)	{		return false;	}//end isPrime	/**	 * This method verifies that the object has been initialized. This should throw	 * an exception if the HashedDictionary has not been properly initialized.	 */	private void checkInitialization()	{	}//end checkInitialization	/**	 * This method checks to ensure the client requests a 	 * capacity that is not too small or too large. This should	 * throw an exception if it too small or too large.	 * @param capacity	 */	private void checkCapacity(int capacity)	{	}//end checkCapacity	/**	 * This method checks the size of the hashtable to determine if it	 * has become too large. Should throw an exception if it has.	 * @param size	 */	private void checkSize(int size)	{	}//end checkSize	/**	 * This private class implements an iterator for 	 * iterating through the dictionary keys.	 * @author Frank M. Carrano	 * @author Timothy M. Henry	 * @author Joseph Erickson	 * @author Rob Kelley	 * @version 4.0	 * Programming Project 1	 * Fall 2018	 */	private class KeyIterator implements Iterator<K>	{		private int currentIndex; // Current position in hash table		private int numberLeft;   // Number of entries left in iteration		/**		 * Constructor initializes the KeyIterator		 */		private KeyIterator() 		{		}//end default constructor		/**		 * Evaluates whether or not there is another 		 * value to iterate over.		 */		public boolean hasNext() 		{			return false;		}//end hasNext		/**		 * This method iterates over the next available value.		 */		public K next()		{			return null;		}//end next		/**		 * Not allowed to remove from this dictionary. Must throw		 * an exception indicating the operation is not supported.		 */		public void remove()		{		}//end remove	}//end KeyIterator	/**	 * This private class implements an iterator for 	 * iterating through the dictionary values.	 * @author Frank M. Carrano	 * @author Timothy M. Henry	 * @author Joseph Erickson	 * @author Rob Kelley	 * Programming Project 1	 * Fall 2018	 */	private class ValueIterator implements Iterator<V>	{		private int currentIndex; // Current position in hash table		private int numberLeft;   // Number of entries left in iteration 		/**		 * This constructor initializes the object.		 */		private ValueIterator() 		{		}//end default constructor		/**		 * Evaluates whether or not there is another 		 * value to iterate over.		 */		public boolean hasNext() 		{			return false;		}//end hasNext		/**		 * This method iterates over the next available value.		 */		public V next()		{			return null;		}//end next		/**		 * Not allowed to remove from this dictionary. Must throw		 * an exception indicating the operation is not supported.		 */		public void remove()		{		}//end remove		}//end ValueIterator	/**	 * This private class implements the table entry for each	 * key/value pair.	 * @author Frank M. Carrano	 * @author Timothy M. Henry	 * @author Joseph Erickson	 * @author Rob Kelley	 * @param <S> - the key	 * @param <T> - the value	 * Programming Project 1	 * Fall 2018	 */	private class TableEntry<S, T>	{		private S key; //key for the table entry		private T value;//value of the table entry		/**		 * This constructor initializes the object.		 * @param searchKey		 * @param dataValue		 */		private TableEntry(S searchKey, T dataValue)		{		}//end constructor		/**		 * This method returns the key.		 * @return - the key		 */		private S getKey()		{			return null;		}//end getKey		/**		 * This method returns the value		 * @return		 */		private T getValue()		{			return null;		}//end getValue		/**		 * This method sets the value 		 * @param newValue - the new value to set.		 */		private void setValue(T newValue)		{		}//end setValue	}//end TableEntry}//end class